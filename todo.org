#+title: Todo

- [X] OPTIMIZATION: do all the draws at the same time. requires adding back vertex
 colors and a bit of refactoring.
  - [X] draw queue with consecutive poly and circle draw calls grouped together so
    that they can be batch drawn together. use instancing for grouped circles
- [X] poly circles as new function / optional
- [X] cache projection matrix
- [X] cull off screen world draws
- [ ] SI Unit system
- [ ] clipping/masking
- [ ] drop shadows 2d
- [ ] Reduce build time
- [ ] cull glyph textures out of view
- [ ] test transform 2 and 3D
- [ ] Unity particle system
- [ ] Compute shaders.
- [ ] frame time in debug
- [ ] color schemes? like built in struct called colour scheme with gruvbox and
  cattpucin and stuff?
- [X] Fix examples now get_input() doesnt exist SPC / get_input
- [ ] use bump allocators for per-frame data that gets cleared
- [ ] texture atlasses
- [ ] Serde feature to make everything publicly facing serializable.
  - [ ] automatic saving and loading support with efficient binary format
- [ ] Transparency is fucked
  - [ ] Very fucked
  - [ ] Someone needs to do something about this
- [ ] Circle anti aliasing between outline and fill
- [X] Move draw param overrides to the material
- [ ] https://github.com/sqrew/tunes
- [ ] Dithering to reduce colour banding
- [ ] Signed distance field / https://raytracing.github.io/books/RayTracingInOneWeekend.html
- [X] Custom materials
- [X] Custom programs
- [X] Post processing [7/7]
  - [X] Bloom
  - [X] Pixelate
    - [X] Would be nice if this actually made it render less pixels but we may
      just need to advise people to use the custom texture rendering method
      below if they care about performance. (documentation!!!)
  - [X] Saturation
  - [X] Hue rotate
  - [X] Brightness
  - [X] Vignette
  - [X] Sharpen?
- [X] finish drawing circle outlines and add support for elipsis and arcs, this can all be one shader if you try hard enough.
- [X] Render to custom texture
  - [X] Create new render pipeline
    - [X] Should be refactored into it's own struct
    - [X] Contains all render queues + some sort of output descriptor
      - [X] May need refactoring for camera's and stuff to use the custom output size
  - [X] Let you use the texture however, like render it to the screen or use it in
    a compute shader like for game of life.
    - [X] Or render to a lower resolution texture and scale it up for a pixelated effect.
- [X] draw hexagon poly thing
- [ ] arbritrary rotation and custom material for all 2d shapes
- [-] TEXT RENDERING!!!
  - [X] fonts
  - [ ] layout / text wrapping / text alignment
  - [ ] rich text
  - [X] text measurement
  - [ ] text scale and rotation
  - [ ] sdf?
- [X] transparant textures?
- [ ] controller support
- [ ] drag and drop files?
- [ ] Animation support
  - [ ] Needs some sort of retained state.
  - [ ] Maybe generic over types that implement some trait.
    - [ ] Implement for all numerics, transform3D, colour, vectors.
  - [ ] Struct contains start, end, time, and interpolation function.
  - [ ] Interpolation function trait.
    - [ ] So you could have structs with configurable interpolation.
  - [ ] sprite animation (needs spritesheets/atlasses)
  - [ ] Animation state machine
- [ ] egui_dock
- [ ] expose egui charts if not already
- [ ] Macros for all this *Ref stuff
- [ ] draw text
  - [ ] draw_fps function
- [ ] 2d mouse camera controller, like whats in the examples but built into the engine
- [ ] Custom keybind/action map struct generic over action enum/struct
- [ ] https://docs.rs/macroquad/latest/macroquad/experimental/animation/index.html
- [ ] https://docs.rs/macroquad/latest/macroquad/experimental/collections/storage/index.html
- [ ] multiple cameras outputting to textures
  - [ ] maybe a use_cameras function
- [X] Render pass
  #+begin_src rust
    pub struct RenderPass {
        pub color_texture: Texture2D,
        pub depth_texture: Option<Texture2D>,
        pub(crate) render_pass: Arc<miniquad::RenderPass>,
    }
    #+end_src
  - [X] we need a function for creating an empty texture and one for creating a render pass from existing textures or just a resolution
  - [X] function to render a texture to the screen as a fullscreen quad
  - [X] just let the user create a render pipeline which has the various draw queues, and let the draw queues also contain their proj matrices so it can be drawn with just a reference to the engine state.
  - [X] let the engine use a default render pipeline, and have it be a vector of impl RenderPipelinePass which is implemented by draw_queue 2 and 3d and for drawing the UI in case the user wants to put things above that.
  this should make it possible to add post processing effects easily
- [ ] drawing curves
  - [ ] lines that connect points
  - [ ] bezier
  - [ ] cubic
  - [ ] quadratic
- [ ] Documentation
- [ ] arcs/slices of circles
- [ ] rounded rectangles
- [ ] splines
- [ ] 2d grid
- [X] function to get screen size, width, height
- [ ] Fix backface culling
- [ ] export all colours as normal consts
- [ ] Transform example
- [ ] change cursor icons
- [ ] Reorganize everything
  Especially draw_queue2d.rs and shapes2d.rs
- [ ] test colours
- [ ] test everything
- [ ] 2D custom materials
  - [ ] use_material & use_default_material functions
  - [ ] add default 2d material to render pipeline
  - [ ] hashmap of material ref to mesh
- [ ] https://github.com/not-fl3/macroquad/blob/master/examples/screen_texture.rs
- [ ] better 2D physics. platformer
- [ ] is this ECS?
  - [ ] this could totally work lets be REAL https://docs.rs/hecs/latest/hecs/
- [ ] lua scripting support
- [ ] more warnings and better errors
- [X] Colors from hex code
- [X] Custom 3D material example
- [X] Batch textures
- [ ] Arbritrary transform of 2D shapes
  - [ ] Transform2D struct
- [ ] 2D & 3D wireframe mode. automatic. can disregard material (maybe? vertex shaders?)
- [ ] Memory/GPU profiler
- [ ] Asset packing
  - [ ] and loading
  - [ ] and a loading screen? customizable maybe just tell give the user some
    statistics about progress and they can render it themselves. sounds good to me
- [ ] benchmarks
- [ ] normal mapping in 2d and 3d
- [ ] metaballs
  - [ ] SDF in 2D?
- [ ] Svelte(fire) style magic for multiplayer. just have some kind of struct /
  macro thing that detects the difference between the state of the struct
  between frames and automatically handles that between players
  - [ ] very high trust level. could be improved. very simple though
- [ ] The... web :(
- [ ] Mobile :(
- [ ] Sound
  - [ ] 2D sound
  - [ ] Include sound
  - [ ] 3D sound
  - [ ] Not happy with sound. need to look into it more
- [ ] Compute shaders
- [X] Convert 2D Primitives to use Z-indexing so batching isnt a problem
- [-] 3D
  - [X] Camera
  - [ ] Primitives
  - [X] Drawing
  - [ ] Culling
  - [X] Importing OBJs
  - [ ] Importing more complex objects that have materials (glTF?)
  - [ ] SDFs
  - [ ] Ray tracing
  - [ ] Instanced ~draw_many~.
  - [ ] Lights
  - [X] Import from blender like godot does (why cant i be more like godot)
  - [X] add mirror BVec3 to transform3d
  - [ ] LOD
- [ ] include_(texture|object|model|sound) macros (macro crate)

* Lucas
- [X] Raycasting
- [X] Collision boxes / area 2D (AABB / circle / polygon)
- [X] Rigid bodies (rapier)
- [X] Custom polygons from shapes
- [X] physics system needs retained state. let the user retain it wherever they want. just put it all in a struct.

* Testing (slop prose)
1. Camera System (src/camera/mod.rs)
The camera transformations are complex and affect everything visual:

screen_to_world() and world_to_screen() roundtrip accuracy
zoom_at() maintaining world point under cursor
visible_bounds() calculations with various transformations
Scale, rotation, and translation combinations
Edge cases with extreme zoom levels

2. Collision Detection (src/collisions/mod.rs)
You already have good collision tests, but consider adding:

Edge cases: zero-radius circles, zero-size squares
Numerical stability with very large/small coordinates
Polygon winding order edge cases
Self-intersecting polygons
Degenerate cases (collinear points in polygons)

3. Draw Queue Z-Ordering (src/draw_queue_2d.rs)
Critical for rendering correctness:

Verify shapes draw in correct order
Test z-value management across multiple queues
Boundary conditions when z approaches limits
Z-increment behavior with many objects

4. Texture Atlas (src/textures/atlas.rs)
Complex packing logic with edge cases:

Atlas growth/reallocation correctness
Sprite retrieval after atlas resize
UV coordinate calculations
Edge cases: sprites exactly fitting remaining space
Memory efficiency with various sprite sizes

5. Material System (src/materials.rs)
Uniform handling can be fragile:

Setting and retrieving different uniform types
Uniform type mismatches
Missing required uniforms for shaders
Material cloning/copying behavior

6. Physics Integration (src/physics.rs)
Wrapper around Rapier2D but still needs tests:

Body creation and retrieval
Collider attachment
Gravity customization
Step simulation determinism
Handle validity after removals

7. Render Pipeline (src/render_pipeline.rs)
Complex state management:

Switching between render targets
Post-processing effect chains
Camera override behavior
Framebuffer attachment correctness
Resource cleanup

8. Input System (src/input.rs)
User-facing API that needs reliability:

Action binding/unbinding
Key press/release/held states
Mouse button state tracking
Action queries with unbound actions
Scroll and cursor position edge cases

9. Object3D Transformations (src/object_3d.rs)
Transform math is error-prone:

Matrix generation from SRT components
Normal matrix calculations
Mirroring behavior (especially culling mode)
Transform composition
Mark dirty/update cycles

10. Color Conversions (src/color.rs)
You have HSL/OKLCH conversions that could have edge cases:

HSL/OKLCH roundtrip accuracy
Hue rotation wrap-around (0°/360°)
Saturation/lightness clamping
Color space boundary values
Alpha channel preservation
