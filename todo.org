#+title: Todo

- [X] OPTIMIZATION: do all the draws at the same time. requires adding back vertex
 colors and a bit of refactoring.
  - [X] draw queue with consecutive poly and circle draw calls grouped together so
    that they can be batch drawn together. use instancing for grouped circles
- [X] poly circles as new function / optional
- [X] cache projection matrix
- [X] cull off screen world draws
- [ ] SI Unit system
- [ ] Compute shaders.
- [ ] Serde feature to make everything publicly facing serializable.
- [ ] Transparency is fucked
- [ ] Move draw param overrides to the material
- [ ] https://github.com/sqrew/tunes
- [ ] Dithering to reduce colour banding
- [ ] Signed distance field / https://raytracing.github.io/books/RayTracingInOneWeekend.html
- [X] Custom materials
- [X] Custom programs
- [ ] Post processing [0/7]
  - [ ] Bloom
  - [ ] Pixelate
    - [ ] Would be nice if this actually made it render less pixels but we may
      just need to advise people to use the custom texture rendering method
      below if they care about performance. (documentation!!!)
  - [ ] Saturation
  - [ ] Hue rotate
  - [ ] Brightness
  - [ ] Vignette
  - [ ] Sharpen?
- [X] finish drawing circle outlines and add support for elipsis and arcs, this can all be one shader if you try hard enough.
- [ ] Render to custom texture
  - [ ] Create new render pipeline
    - [ ] Should be refactored into it's own struct
    - [ ] Contains all render queues + some sort of output descriptor
      - [ ] May need refactoring for camera's and stuff to use the custom output size
  - [ ] Let you use the texture however, like render it to the screen or use it in
    a compute shader like for game of life.
    - [ ] Or render to a lower resolution texture and scale it up for a pixelated effect.
- [ ] draw hexagon poly thing
- [ ] arbritrary rotation and custom material for all 2d shapes
- [ ] Animation support
  - [ ] Needs some sort of retained state.
  - [ ] Maybe generic over types that implement some trait.
    - [ ] Implement for all numerics, transform3D, colour, vectors.
  - [ ] Struct contains start, end, time, and interpolation function.
  - [ ] Interpolation function trait.
    - [ ] So you could have structs with configurable interpolation.
- [ ] draw text
  - [ ] draw_fps function
- [ ] 2d mouse camera controller, like whats in the examples but built into the engine
- [ ] Custom keybind/action map struct generic over action enum/struct
- [ ] https://docs.rs/macroquad/latest/macroquad/experimental/animation/index.html
- [ ] https://docs.rs/macroquad/latest/macroquad/experimental/collections/storage/index.html
- [ ] automatic saving and loading support with efficient binary format
- [ ] multiple cameras
- [ ] Render pass
  #+begin_src rust
    pub struct RenderPass {
        pub color_texture: Texture2D,
        pub depth_texture: Option<Texture2D>,
        pub(crate) render_pass: Arc<miniquad::RenderPass>,
    }
    #+end_src
  - [ ] we need a function for creating an empty texure and one for creating a render pass from existing textures or just a resolution
  - [ ] function to render a texture to the screen as a fullscreen quad
  - [ ] just let the user create a render pipeline which has the various draw queues, and let the draw queues also contain their proj matrices so it can be drawn with just a reference to the engine state.
  - [ ] let the engine use a default render pipeline, and have it be a vector of impl RenderPipelinePass which is implemented by draw_queue 2 and 3d and for drawing the UI in case the user wants to put things above that.
  this should make it possible to add post processing effects easily
- [ ] drawing curves
  - [ ] lines that connect points
  - [ ] bezier
  - [ ] cubic
- [ ] Documentation
- [ ] function to get screen size, width, height
- [ ] Fix backface culling
- [ ] export all colours as normal consts
- [ ] Transform example
- [ ] change cursor icons
- [ ] Reorganize everything
  - [ ] Especially draw_queue2d.rs and shapes2d.rs
- [ ] test colours
- [ ] test everything
- [ ] 2D custom materials
- [ ] Colors from hex code
- [ ] Custom 3D material example
- [X] Batch textures
- [ ] Arbritrary transform of 2D shapes
  - [ ] Transform2D struct
- [ ] Sound
  - [ ] 2D sound
  - [ ] 3D sound
- [ ] Compute shaders
- [X] Convert 2D Primitives to use Z-indexing so batching isnt a problem
- [-] 3D
  - [X] Camera
  - [ ] Primitives
  - [X] Drawing
  - [ ] Culling
  - [X] Importing OBJs
  - [ ] Importing more complex objects that have materials (glTF?)
  - [ ] SDFs
  - [ ] Ray tracing
  - [ ] Instanced ~draw_many~.
  - [ ] Lights
  - [X] Import from blender like godot does (why cant i be more like godot)
  - [X] add mirror BVec3 to transform3d
  - [ ] LOD
- [ ] include_(texture|object|model|sound) macros (macro crate)

* Lucas
- [X] Raycasting
- [X] Collision boxes / area 2D (AABB / circle / polygon)
- [X] Rigid bodies (rapier)
- [X] Custom polygons from shapes
- [X] physics system needs retained state. let the user retain it wherever they want. just put it all in a struct.

* Performance Optimizations
** Rendering

 - [ ] Persistent vertex/index buffers: Reuse buffers across frames instead of recreating them
 - [ ] Buffer orphaning: Use glBufferData(NULL) pattern to avoid GPU stalls
 - [ ] Texture atlasing: If you add textures, pack them into atlases to reduce state changes
 - [X] Occlusion culling: Don't even add shapes to draw queue if they're completely outside view
 - [ ] Level of Detail (LOD): Reduce polygon count for distant objects (fewer sides on distant polygons)
 - [ ] Depth buffer usage: Instead of draw order, use actual depth testing
 - [ ] Shader hot-reloading: Automatically reload shaders when files change during development
 - [ ] Multi-threaded draw queue building: Build draw queues on separate threads
 - [ ] GPU instancing for more shapes: Instance rectangles, triangles, polygons too
 - [ ] Uniform buffer objects (UBOs): Share projection matrices across draw calls more efficiently

** Memory

 - [ ] Object pooling: Reuse allocations for vertices/indices instead of creating new vectors
 - [ ] Arena allocators: Use bump allocators for per-frame data that gets cleared
 - [ ] Shape capacity hints: Let users reserve capacity if they know they'll draw many shapes
 - [ ] Sparse storage: For world objects, use spatial hash or quadtree instead of linear storage

** Camera

 - [ ] Camera projection caching: Only recalculate when camera actually changes
 - [ ] Frustum culling optimization: Use SIMD for bounds checking
 - [ ] Chunk-based culling: Group world objects into chunks for faster culling

* New Features
** Graphics Features [1/15]
 - [X] Textures: Load and render textured quads/sprites
 - [ ] Sprite batching: Automatically batch sprites from same texture
 - [ ] 9-slice scaling: For UI elements
 - [ ] Gradient fills: Linear/radial gradients for shapes
 - [ ] Stroke styles: Dashed lines, rounded caps, different join styles
 - [ ] Anti-aliasing: MSAA or FXAA support
 - [ ] Post-processing effects: Bloom, blur, color grading
 - [ ] Particle systems: Efficient batched particle rendering
 - [ ] Custom shaders: Let users provide their own shaders
 - [ ] Render targets: Draw to textures for off-screen rendering
 - [ ] Layers/render passes: Explicit control over draw order
 - [ ] Blend modes: Additive, multiply, etc.
 - [ ] Clipping/masking: Clip drawing to regions
 - [ ] Shadows: Simple drop shadows or more complex shadow mapping
 - [ ] Lower resolution support like the software renderer

** Shapes & Primitives [1/9]

 - [ ] Bezier curves: Quadratic and cubic curves
 - [ ] Arcs and pie slices: Partial circles
 - [ ] Rounded rectangles: With configurable corner radii
 - [ ] Ellipses: Non-circular ellipses
 - [X] Polylines: Connected line segments with joins
 - [ ] Splines: Smooth curves through points
 - [ ] Grid helpers: Draw coordinate grids
 - [ ] Axes helpers: Visual coordinate axes
 - [ ] Filled polygons with holes: For complex shapes

** Text Rendering [0/7]

 - [ ] Text drawing: Integrate a text rendering library (e.g., glyph_brush)
 - [ ] Font loading: TTF/OTF support
 - [ ] Text alignment: Left/center/right, top/middle/bottom
 - [ ] Text wrapping: Automatic line breaking
 - [ ] Rich text: Multiple fonts/colors in one string
 - [ ] Text measurement: Get bounds before rendering
 - [ ] SDF text rendering: For crisp text at any scale

** Input Handling [0/6]

 - [ ] Touch support: Multi-touch gestures
 - [ ] Gamepad support: Controller input
 - [ ] Input mapping: Rebindable controls
 - [ ] Input recording/playback: For debugging and demos
 - [ ] Mouse cursor customization: Custom cursor images
 - [ ] Drag and drop: File/object drag and drop support

** Camera Enhancements [0/7]

 - [ ] Camera presets: Orthographic, perspective, isometric
 - [ ] Camera shake: For game effects
 - [ ] Camera smoothing/easing: Smooth movement and zoom
 - [ ] Follow target: Camera that smoothly follows an object
 - [ ] Camera bounds: Constrain camera to specific world area
 - [ ] Split-screen: Multiple cameras/viewports
 - [ ] Minimap: Picture-in-picture camera view

** Scene Management [0/5]

 - [ ] Scene graph: Hierarchical object transforms
 - [ ] Entity-Component-System: Proper ECS architecture
 - [ ] Object tags/layers: Group and filter objects
 - [ ] Spatial partitioning: Quadtree/octree for world objects
 - [ ] Serialization: Save/load scenes to/from files

** Animation [0/5]

 - [ ] Tweening: Smooth interpolation between values
 - [ ] Animation curves: Easing functions
 - [ ] Keyframe animation: Timeline-based animations
 - [ ] Sprite animation: Frame-based sprite sheets
 - [ ] Skeletal animation: For complex character animation

** UI System [0/5]

 - [ ] Immediate mode UI improvements: Better layouts, more widgets
 - [ ] Docking: Dock windows like an IDE
 - [ ] Themes: Customizable UI appearance
 - [ ] Charts/graphs: Built-in data visualization
 - [ ] Custom widgets: Easy widget creation API

** Audio [0/4]

 - [ ] Audio playback: Sound effects and music
 - [ ] 3D audio: Positional audio based on camera
 - [ ] Audio mixing: Volume control, fading
 - [ ] Streaming: Stream large audio files

** Physics [0/4]

 - [ ] 2D physics integration: Integrate rapier2d or similar
 - [ ] Collision detection: AABB, circle, polygon collisions
 - [ ] Raycasting: Ray-shape intersection tests
 - [ ] Trigger volumes: Detect object overlaps

** Debugging & Profiling [1/8]

 - [X] Performance overlay: FPS, draw calls, vertex count, etc.
 - [ ] Shape bounds visualization: Show AABBs
 - [ ] Wireframe mode: Render only outlines
 - [ ] Debug drawing: Persistent debug lines/shapes
 - [ ] Memory profiler: Track allocations
 - [ ] GPU profiler integration: Use graphics debuggers
 - [ ] Screenshot/video capture: Built-in capture functionality
 - [ ] Inspector panel: Select and inspect objects at runtime

** File I/O [0/4]

 # - [ ] Image loading: PNG, JPG, etc.
 - [ ] SVG support: Vector graphics import
 - [ ] Asset hot-reloading: Auto-reload changed assets
 - [ ] Asset packing: Bundle assets into single files
 - [ ] Save/load game state: Serialization utilities

** Networking [0/3]

 - [ ] Network sync: Multiplayer support
 - [ ] Replay system: Record and playback sessions
 - [ ] Cloud saves: Save game state to cloud

** Build & Distribution [0/4]

 - [ ] Web target: Compile to WebAssembly
 - [ ] Mobile support: Android/iOS targets
 - [ ] Asset bundling: Package assets with executable
 - [ ] Automatic builds: CI/CD integration

** Quality of Life [0/7]

 - [ ] Error recovery: Graceful handling of GPU errors
 - [ ] Asset validation: Check assets at load time
 - [ ] Performance warnings: Warn about inefficient usage
 - [ ] API documentation: Comprehensive docs with examples
 - [ ] Example projects: Gallery of demo projects
 - [ ] Benchmarking suite: Performance regression tests
 - [ ] Undo/redo system: For editor-like applications

** Advanced Graphics [0/6]

 - [ ] Normal mapping: For pseudo-3D effects
 - [ ] Lighting system: 2D dynamic lighting
 - [ ] Deferred rendering: More complex lighting scenarios
 - [ ] Compute shaders: GPU-accelerated processing
 - [ ] Signed distance fields: For complex 2D effects
 - [ ] Metaballs: Fluid-like shapes
