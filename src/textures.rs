use std::{
    io::Cursor,
    ops::{Deref, DerefMut, Index, IndexMut},
};

use bevy_math::{UVec2, Vec2};
use glium::{
    Texture2d, implement_vertex,
    texture::{RawImage2d, TextureCreationError},
    uniforms::{MagnifySamplerFilter, MinifySamplerFilter},
};
use image::ImageFormat;

use crate::{EngineDisplay, EngineStorage, get_state, image::Image};

pub mod atlas;

pub const DUMMY_TEXTURE: TextureRef = TextureRef(0);

#[derive(Clone, Copy)]
pub struct TexturedVertex2D {
    pub position: [f32; 2],
    pub tex_coords: [f32; 2],
}
implement_vertex!(TexturedVertex2D, position, tex_coords);

pub(crate) const UNIT_SQUARE: [TexturedVertex2D; 4] = [
    TexturedVertex2D {
        position: [-1.0, -1.0],
        tex_coords: [0.0, 0.0],
    },
    TexturedVertex2D {
        position: [1.0, -1.0],
        tex_coords: [1.0, 0.0],
    },
    TexturedVertex2D {
        position: [-1.0, 1.0],
        tex_coords: [0.0, 1.0],
    },
    TexturedVertex2D {
        position: [1.0, 1.0],
        tex_coords: [1.0, 1.0],
    },
];

pub fn init_textures(storage: &mut EngineStorage, display: &EngineDisplay) {
    let dummy_image = RawImage2d::from_raw_rgb(vec![255u8, 255u8, 255u8], (1, 1));
    let dummy_texture = Texture2d::with_format(
        display,
        dummy_image,
        glium::texture::UncompressedFloatFormat::U8U8U8U8,
        glium::texture::MipmapsOption::NoMipmap,
    )
    .unwrap();
    let dummy = EngineTexture {
        dimensions: UVec2::ONE,
        normalized_dimensions: Vec2::ONE,
        gl_texture: dummy_texture,
        magnify_filter: MagnifySamplerFilter::Nearest,
        minify_filter: MinifySamplerFilter::Nearest,
    };
    storage.textures.push(dummy);
}

pub fn load_texture(bytes: &[u8], format: ImageFormat) -> anyhow::Result<TextureRef> {
    Ok(EngineTexture::load_from_bytes(bytes, format)?.create())
}

pub struct EngineTexture {
    pub dimensions: UVec2,
    pub normalized_dimensions: Vec2,
    pub gl_texture: Texture2d,
    pub magnify_filter: MagnifySamplerFilter,
    pub minify_filter: MinifySamplerFilter,
}

impl EngineTexture {
    pub fn static_gl_texture(&'static self) -> &'static Texture2d {
        &self.gl_texture
    }

    pub fn load_from_bytes(bytes: &[u8], format: ImageFormat) -> anyhow::Result<Self> {
        let state = get_state();

        let image = image::load(Cursor::new(bytes), format)?.to_rgba8();
        let image_dimensions = image.dimensions();
        let image = RawImage2d::from_raw_rgba(image.into_raw(), image_dimensions);
        Ok(Self::from_raw(image)?)
    }

    pub fn new(texture: Texture2d) -> EngineTexture {
        let state = get_state();
        let dimensions = texture.dimensions().into();
        EngineTexture {
            dimensions,
            gl_texture: texture,
            normalized_dimensions: Self::create_normalized_dimensions(dimensions.x, dimensions.y),
            magnify_filter: state.config.default_magnify_filter,
            minify_filter: state.config.default_minify_filter,
        }
    }

    fn create_normalized_dimensions(width: u32, height: u32) -> Vec2 {
        let mut v = Vec2::new(width as f32, height as f32);
        let max = v.x.max(v.y);
        v.x /= max;
        v.y /= max;
        v
    }

    pub fn create(self) -> TextureRef {
        let state = get_state();
        let id = state.storage.textures.len();
        state.storage.textures.push(self);

        TextureRef(id)
    }

    pub fn empty(width: u32, height: u32) -> Result<Self, TextureCreationError> {
        let state = get_state();
        Ok(Self::new(Texture2d::empty(&state.display, width, height)?))
    }

    pub fn from_engine_image(image: Image) -> Result<Self, TextureCreationError> {
        let dimensions = image.dimensions_u32().into();
        let raw = RawImage2d::from_raw_rgba(image.into_bytes(), dimensions);
        Self::from_raw(raw)
    }

    pub fn from_raw(raw: RawImage2d<'_, u8>) -> Result<Self, TextureCreationError> {
        let state = get_state();
        let texture = Texture2d::with_format(
            &state.display,
            raw,
            glium::texture::UncompressedFloatFormat::U8U8U8U8,
            if state.config.use_mipmaps {
                glium::texture::MipmapsOption::AutoGeneratedMipmaps
            } else {
                glium::texture::MipmapsOption::NoMipmap
            },
        )?;

        Ok(EngineTexture::new(texture))
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Ord, PartialOrd, Hash)]
pub struct TextureRef(pub usize);

impl TextureRef {
    pub(crate) fn get(&self) -> &'static EngineTexture {
        &get_state().storage.textures[self.0]
    }

    pub fn get_mut(&self) -> &'static mut EngineTexture {
        &mut get_state().storage.textures[self.0]
    }

    pub fn dimensions(&self) -> UVec2 {
        self.get().dimensions
    }

    pub fn normalized_dimensions(&self) -> Vec2 {
        self.get().normalized_dimensions
    }

    pub fn new() -> Self {
        let id = get_state().storage.textures.len();
        Self(id)
    }
}

impl Deref for TextureRef {
    type Target = EngineTexture;
    fn deref(&self) -> &Self::Target {
        &get_state().storage.textures[self.0]
    }
}

impl DerefMut for TextureRef {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut get_state().storage.textures[self.0]
    }
}

impl Index<TextureRef> for EngineStorage {
    type Output = EngineTexture;
    fn index(&self, index: TextureRef) -> &Self::Output {
        &self.textures[index.0]
    }
}

impl IndexMut<TextureRef> for EngineStorage {
    fn index_mut(&mut self, index: TextureRef) -> &mut Self::Output {
        &mut self.textures[index.0]
    }
}
