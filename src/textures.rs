use std::io::Cursor;

use bevy_math::{UVec2, Vec2};
use engine_4_macros::gen_ref_type;
use glium::{
    Texture2d, implement_vertex,
    texture::{RawImage2d, TextureCreationError},
    uniforms::{MagnifySamplerFilter, MinifySamplerFilter},
};
use image::ImageFormat;

use crate::utils::EngineCreate;
use crate::{EngineDisplay, EngineStorage, get_state, image::Image};

pub mod atlas;

// pub const DUMMY_TEXTURE: TextureRef = TextureRef(0);

#[derive(Clone, Copy)]
pub struct TexturedVertex2D {
    pub position: [f32; 2],
    pub tex_coords: [f32; 2],
}
implement_vertex!(TexturedVertex2D, position, tex_coords);

// pub(crate) const UNIT_SQUARE: [TexturedVertex2D; 4] = [
//     TexturedVertex2D {
//         position: [-1.0, -1.0],
//         tex_coords: [0.0, 0.0],
//     },
//     TexturedVertex2D {
//         position: [1.0, -1.0],
//         tex_coords: [1.0, 0.0],
//     },
//     TexturedVertex2D {
//         position: [-1.0, 1.0],
//         tex_coords: [0.0, 1.0],
//     },
//     TexturedVertex2D {
//         position: [1.0, 1.0],
//         tex_coords: [1.0, 1.0],
//     },
// ];

pub fn init_textures(_storage: &mut EngineStorage, _display: &EngineDisplay) {
    // let dummy_image = RawImage2d::from_raw_rgb(vec![255u8, 255u8, 255u8], (1, 1));
    // let dummy_texture = Texture2d::with_format(
    //     display,
    //     dummy_image,
    //     glium::texture::UncompressedFloatFormat::U8U8U8U8,
    //     glium::texture::MipmapsOption::NoMipmap,
    // )
    // .unwrap();
    // let dummy = EngineTexture {
    //     dimensions: UVec2::ONE,
    //     normalized_dimensions: Vec2::ONE,
    //     gl_texture: dummy_texture,
    //     magnify_filter: MagnifySamplerFilter::Nearest,
    //     minify_filter: MinifySamplerFilter::Nearest,
    // };
    // storage.textures.push(dummy);
}

pub fn load_texture(bytes: &[u8], format: ImageFormat) -> anyhow::Result<TextureRef> {
    Ok(EngineTexture::load_from_bytes(bytes, format)?.create())
}

pub struct EngineTexture {
    pub dimensions: UVec2,
    pub normalized_dimensions: Vec2,
    pub gl_texture: Texture2d,
    pub magnify_filter: MagnifySamplerFilter,
    pub minify_filter: MinifySamplerFilter,
}

impl EngineTexture {
    pub fn static_gl_texture(&'static self) -> &'static Texture2d {
        &self.gl_texture
    }

    pub fn load_from_bytes(bytes: &[u8], format: ImageFormat) -> anyhow::Result<Self> {
        let image = image::load(Cursor::new(bytes), format)?.to_rgba8();
        let image_dimensions = image.dimensions();
        let image = RawImage2d::from_raw_rgba(image.into_raw(), image_dimensions);
        Ok(Self::from_raw(image)?)
    }

    pub fn new(texture: Texture2d) -> EngineTexture {
        let state = get_state();
        let dimensions = texture.dimensions().into();
        EngineTexture {
            dimensions,
            gl_texture: texture,
            normalized_dimensions: Self::create_normalized_dimensions(dimensions.x, dimensions.y),
            magnify_filter: state.config.default_magnify_filter,
            minify_filter: state.config.default_minify_filter,
        }
    }

    pub(crate) fn create_normalized_dimensions(width: u32, height: u32) -> Vec2 {
        let mut v = Vec2::new(width as f32, height as f32);
        let max = v.x.max(v.y);
        v.x /= max;
        v.y /= max;
        v
    }

    pub fn empty(width: u32, height: u32) -> Result<Self, TextureCreationError> {
        let state = get_state();
        Ok(Self::new(Texture2d::empty(&state.display, width, height)?))
    }

    pub fn from_engine_image(image: Image) -> Result<Self, TextureCreationError> {
        let dimensions = image.dimensions_u32().into();
        let raw = RawImage2d::from_raw_rgba(image.into_bytes(), dimensions);
        Self::from_raw(raw)
    }

    pub fn from_raw(raw: RawImage2d<'_, u8>) -> Result<Self, TextureCreationError> {
        let state = get_state();
        let texture = Texture2d::with_format(
            &state.display,
            raw,
            glium::texture::UncompressedFloatFormat::U8U8U8U8,
            if state.config.use_mipmaps {
                glium::texture::MipmapsOption::AutoGeneratedMipmaps
            } else {
                glium::texture::MipmapsOption::NoMipmap
            },
        )?;

        Ok(EngineTexture::new(texture))
    }
}

gen_ref_type!(EngineTexture, TextureRef, textures);

impl TextureRef {
    pub fn dimensions(&self) -> UVec2 {
        self.get().dimensions
    }

    pub fn normalized_dimensions(&self) -> Vec2 {
        self.get().normalized_dimensions
    }
}
