use std::{
    io::Cursor,
    ops::{Deref, DerefMut},
};

use bevy_math::{UVec2, Vec2};
use glium::{
    Texture2d, implement_vertex,
    texture::RawImage2d,
    uniforms::{MagnifySamplerFilter, MinifySamplerFilter},
};
use image::ImageFormat;

use crate::{
    EngineDisplay, EngineStorage, color::Color, draw_queue_2d::DrawQueue2D,
    draw_queue_3d::DrawQueue3D, get_state, post_processing::PostProcessingEffect,
};

pub const DUMMY_TEXTURE: TextureRef = TextureRef(0);

#[derive(Clone, Copy)]
pub struct TexturedVertex2D {
    pub position: [f32; 2],
    pub tex_coords: [f32; 2],
}
implement_vertex!(TexturedVertex2D, position, tex_coords);

pub(crate) const UNIT_SQUARE: [TexturedVertex2D; 4] = [
    TexturedVertex2D {
        position: [-1.0, -1.0],
        tex_coords: [0.0, 0.0],
    },
    TexturedVertex2D {
        position: [1.0, -1.0],
        tex_coords: [1.0, 0.0],
    },
    TexturedVertex2D {
        position: [-1.0, 1.0],
        tex_coords: [0.0, 1.0],
    },
    TexturedVertex2D {
        position: [1.0, 1.0],
        tex_coords: [1.0, 1.0],
    },
];

pub fn init_textures(storage: &mut EngineStorage, display: &EngineDisplay) {
    let dummy_image = RawImage2d::from_raw_rgb(vec![255u8, 255u8, 255u8], (1, 1));
    let dummy_texture = Texture2d::with_format(
        display,
        dummy_image,
        glium::texture::UncompressedFloatFormat::U8U8U8U8,
        glium::texture::MipmapsOption::NoMipmap,
    )
    .unwrap();
    let dummy = EngineTexture {
        dimensions: UVec2::ONE,
        normalized_dimensions: Vec2::ONE,
        gl_texture: dummy_texture,
        magnify_filter: MagnifySamplerFilter::Nearest,
        minify_filter: MinifySamplerFilter::Nearest,
    };
    storage.textures.push(dummy);
}

pub fn load_texture(bytes: &[u8], format: ImageFormat) -> anyhow::Result<TextureRef> {
    let state = get_state();

    let image = image::load(Cursor::new(bytes), format)?.to_rgba8();
    let image_dimensions = image.dimensions();
    let image = RawImage2d::from_raw_rgba(image.into_raw(), image_dimensions);
    let texture = Texture2d::with_format(
        &state.display,
        image,
        glium::texture::UncompressedFloatFormat::U8U8U8U8,
        if state.config.use_mipmaps {
            glium::texture::MipmapsOption::AutoGeneratedMipmaps
        } else {
            glium::texture::MipmapsOption::NoMipmap
        },
    )?;

    Ok(EngineTexture::new(texture).create())
}

pub struct EngineTexture {
    pub dimensions: UVec2,
    pub normalized_dimensions: Vec2,
    pub gl_texture: Texture2d,
    pub magnify_filter: MagnifySamplerFilter,
    pub minify_filter: MinifySamplerFilter,
}

impl EngineTexture {
    pub fn static_gl_texture(&'static self) -> &'static Texture2d {
        &self.gl_texture
    }

    pub fn new(texture: Texture2d) -> EngineTexture {
        let state = get_state();
        let dimensions = texture.dimensions().into();
        EngineTexture {
            dimensions,
            gl_texture: texture,
            normalized_dimensions: {
                let mut v = Vec2::new(dimensions.x as f32, dimensions.y as f32);
                let max = v.x.max(v.y);
                v.x /= max;
                v.y /= max;
                v
            },
            magnify_filter: state.config.default_magnify_filter,
            minify_filter: state.config.default_minify_filter,
        }
    }

    pub fn create(self) -> TextureRef {
        let state = get_state();
        let id = state.storage.textures.len();
        state.storage.textures.push(self);

        TextureRef(id)
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Ord, PartialOrd, Hash)]
pub struct TextureRef(pub usize);

impl TextureRef {
    pub(crate) fn get(&self) -> &'static EngineTexture {
        &get_state().storage.textures[self.0]
    }

    pub fn get_mut(&self) -> &'static mut EngineTexture {
        &mut get_state().storage.textures[self.0]
    }

    pub fn dimensions(&self) -> UVec2 {
        self.get().dimensions
    }

    pub fn normalized_dimensions(&self) -> Vec2 {
        self.get().normalized_dimensions
    }

    pub fn new() -> Self {
        let id = get_state().storage.textures.len();
        Self(id)
    }
}

impl Deref for TextureRef {
    type Target = EngineTexture;
    fn deref(&self) -> &Self::Target {
        &get_state().storage.textures[self.0]
    }
}

impl DerefMut for TextureRef {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut get_state().storage.textures[self.0]
    }
}
